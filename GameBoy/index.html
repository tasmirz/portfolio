<canvas id="c" width="1280" height="720"></canvas>
<script>
	const gl = c.getContext('webgl2', { alpha: false, antialias: false })
	if (!gl) throw new Error('WebGL2 required')

	// --- Shaders (same as before) ---
	const vs = `#version 300 es
layout(location=0) in vec2 aPos;
layout(location=1) in vec2 iPos;
layout(location=2) in float iRot;
layout(location=3) in vec2 iScale;
layout(location=4) in vec4 iUV;
layout(location=5) in vec4 iTint;
uniform mat3 uView;
uniform vec2 uParallax;
out vec2 vUV;
out vec4 vTint;
void main(){
  float s=sin(iRot), c=cos(iRot);
  mat2 R = mat2(c,-s,s,c);
  vec2 world = iPos + (R*(aPos*iScale));
  vec3 cam = uView * vec3(world*uParallax,1.0);
  gl_Position = vec4(cam.xy,0.0,1.0);
  vUV = iUV.xy + aPos*0.5*iUV.zw + iUV.zw*0.5;
  vTint = iTint;
}`
	const fs = `#version 300 es
precision mediump float;
in vec2 vUV;
in vec4 vTint;
uniform sampler2D uAtlas;
out vec4 o;
void main(){ o = texture(uAtlas,vUV)*vTint; }`

	// --- Compile program ---
	function compile(type, src) {
		const s = gl.createShader(type)
		gl.shaderSource(s, src)
		gl.compileShader(s)
		if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
			throw gl.getShaderInfoLog(s)
		return s
	}
	const prog = gl.createProgram()
	gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs))
	gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs))
	gl.linkProgram(prog)

	if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
		throw gl.getProgramInfoLog(prog)

	// --- Unit quad ---
	const vao = gl.createVertexArray()
	gl.bindVertexArray(vao)
	const quad = new Float32Array([-0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5])
	const vbo = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, vbo)
	gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW)
	gl.enableVertexAttribArray(0)
	gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8, 0)

	// --- Instance buffer ---
	const maxInstances = 65536,
		stride = (2 + 1 + 2 + 4 + 4) * 4
	const ibo = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, ibo)
	gl.bufferData(gl.ARRAY_BUFFER, maxInstances * stride, gl.DYNAMIC_DRAW)
	let offset = 0
	function at(loc, comps) {
		gl.enableVertexAttribArray(loc)
		gl.vertexAttribPointer(loc, comps, gl.FLOAT, false, stride, offset)
		gl.vertexAttribDivisor(loc, 1)
		offset += comps * 4
	}
	at(1, 2)
	at(2, 1)
	at(3, 2)
	at(4, 4)
	at(5, 4)

	// --- Uniforms ---
	const u = {
		view: gl.getUniformLocation(prog, 'uView'),
		parallax: gl.getUniformLocation(prog, 'uParallax'),
		atlas: gl.getUniformLocation(prog, 'uAtlas')
	}

	// --- Texture placeholder ---
	const tex = gl.createTexture()
	gl.bindTexture(gl.TEXTURE_2D, tex)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.texImage2D(
		gl.TEXTURE_2D,
		0,
		gl.RGBA,
		1,
		1,
		0,
		gl.RGBA,
		gl.UNSIGNED_BYTE,
		new Uint8Array([255, 255, 255, 255])
	)

	// --- Layers ---
	const layers = [
		{ parallax: [0.6, 0.6], count: 0 },
		{ parallax: [1.0, 1.0], count: 0 },
		{ parallax: [1.2, 1.2], count: 0 }
	]

	// --- Instance array ---
	let instanceCount = 0
	const f32 = new Float32Array(maxInstances * (stride / 4))
	function pushInstance(x, y, rot, sx, sy, uvx, uvy, uvw, uvh, r, g, b, a) {
		const base = instanceCount * (stride / 4)
		f32[base + 0] = x
		f32[base + 1] = y
		f32[base + 2] = rot
		f32[base + 3] = sx
		f32[base + 4] = sy
		f32[base + 5] = uvx
		f32[base + 6] = uvy
		f32[base + 7] = uvw
		f32[base + 8] = uvh
		f32[base + 9] = r
		f32[base + 10] = g
		f32[base + 11] = b
		f32[base + 12] = a
		instanceCount++
	}

	// --- Buildings ---
	for (let i = 0; i < 20; i++) {
		pushInstance(
			Math.random() * 2000,
			Math.random() * 1200,
			0,
			64,
			64,
			0,
			0,
			1,
			1,
			0.7,
			0.7,
			0.7,
			1
		)
	}
	layers[1].count = 20

	// --- Player ---
	let player = { x: 640, y: 360, speed: 4 }
	pushInstance(player.x, player.y, 0, 32, 32, 0, 0, 1, 1, 1, 0, 0, 1)
	layers[1].count++

	gl.bindBuffer(gl.ARRAY_BUFFER, ibo)
	gl.bufferSubData(gl.ARRAY_BUFFER, 0, f32)

	// --- Camera ---
	let cam = { x: 0, y: 0, w: 640, h: 360 }
	const keys = {}
	window.addEventListener('keydown', (e) => (keys[e.key.toLowerCase()] = true))
	window.addEventListener('keyup', (e) => (keys[e.key.toLowerCase()] = false))

	// --- Boundaries ---
	const bounds = { xMin: 0, yMin: 0, xMax: 2000, yMax: 1200 }

	// --- Ortho ---
	function ortho2D(x, y, w, h) {
		return new Float32Array([
			2 / w,
			0,
			0,
			0,
			-2 / h,
			0,
			(-2 * x) / w - 1,
			(2 * y) / h + 1,
			1
		])
	}

	// --- Frame loop ---
	function frame() {
		// move player
		if (keys['w']) player.y -= player.speed
		if (keys['s']) player.y += player.speed
		if (keys['a']) player.x -= player.speed
		if (keys['d']) player.x += player.speed
		// clamp
		player.x = Math.max(bounds.xMin, Math.min(bounds.xMax, player.x))
		player.y = Math.max(bounds.yMin, Math.min(bounds.yMax, player.y))

		// update player instance
		const base = (layers[1].count - 1) * (stride / 4)
		f32[base + 0] = player.x
		f32[base + 1] = player.y
		gl.bindBuffer(gl.ARRAY_BUFFER, ibo)
		gl.bufferSubData(
			gl.ARRAY_BUFFER,
			base * 4,
			f32.subarray(base, base + stride / 4)
		)

		// camera centered on player
		cam.x = player.x - cam.w / 2
		cam.y = player.y - cam.h / 2

		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)
		gl.clearColor(0.5, 0.8, 1, 1)
		gl.clear(gl.COLOR_BUFFER_BIT)
		gl.useProgram(prog)
		gl.bindVertexArray(vao)
		gl.activeTexture(gl.TEXTURE0)
		gl.bindTexture(gl.TEXTURE_2D, tex)
		gl.uniform1i(u.atlas, 0)
		gl.uniformMatrix3fv(u.view, false, ortho2D(cam.x, cam.y, cam.w, cam.h))

		let b = 0
		for (const L of layers) {
			gl.uniform2fv(u.parallax, new Float32Array(L.parallax))
			gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, L.count)
			b += L.count
		}
		requestAnimationFrame(frame)
	}
	requestAnimationFrame(frame)
</script>
